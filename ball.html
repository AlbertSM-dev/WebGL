<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" src="https://getfirebug.com/firebug-lite-debug.js"></script>
<meta name="description" content="CS4406 Computer Graphics - Exercise #3" />
  	<meta charset="utf-8" />
	<title>Unit 3 Three.js</title>

<meta charset=utf-8 />
<title>CS4406 Computer Graphics - Exercise #3</title>
  
<style id="jsbin-css">

</style>
</head>
<body>
<div id="container">
</div>
</body>
    <script src="http://uopeopleweb.com/js/jquery-1.10.2.min.js"></script> 
    <script src="http://uopeopleweb.com/three.js/build/three.min.js"></script>
    <script src="http://uopeopleweb.com/js/dat.gui.min.js"></script>
	<script src="http://uopeopleweb.com/js/OrbitControls.js"></script>
	<script src="http://uopeopleweb.com/js/math.js"></script>
<script src="https://threejs.org/examples/js/Detector.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

	<script type="text/javascript">
var WIDTH = 500;
        var HEIGHT = 500;
        
        // Define the "Play Area" size
        var PLAY_WIDTH = 500;
        var PLAY_HEIGHT = 500;

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        var scene = new THREE.Scene();
        
        // 2. Camera Setup
        // We place the camera back far enough to see the whole 500x500 area
        var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 1000);
        camera.position.z = 800; 
         
        scene.add(camera);

	// ----------------------------------------------------------------------------------------
	//  END OF THE STANDARD CODE FOR THE ASSIGNMENT
	//  Following this is where you must place your own custom code to complete the assignment
	// ---------------------------------------------------------------------------------------
// Ball material should respond to light
var circleMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });

// Ball geometry
var radius = 20, segments = 32;
var circle = new THREE.Mesh(
   new THREE.CircleGeometry(radius, segments),
   circleMaterial
);
circle.position.set(0, 0, 10); // move slightly forward so it's not hidden by plane
circle.castShadow = true;
scene.add(circle);

// Plane background (push back so ball is visible)
var planeGeo = new THREE.PlaneGeometry(WIDTH, HEIGHT);
var planeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFAA, side: THREE.DoubleSide });
var plane = new THREE.Mesh(planeGeo, planeMat);
plane.position.set(0, 0, -1); // behind the ball
plane.receiveShadow = true;
scene.add(plane);

// Border edges
var borderGeo = new THREE.EdgesGeometry(planeGeo);
var borderMat = new THREE.LineBasicMaterial({ color: 0x000000 });
var border = new THREE.LineSegments(borderGeo, borderMat);
border.position.set(0, 0, -0.9); // align with plane
scene.add(border);

// Light source in upper-left corner
var light = new THREE.PointLight(0xFFFFAA, 1, 500);
light.position.set(-250, 250, 250); // upper-left, closer to center
light.castShadow = true;
scene.add(light);

// Ambient light for softer shadows
var ambientLight = new THREE.AmbientLight(0x404040);
scene.add(ambientLight);

function setRandomColor(mat) {
  const hue = Math.random();         // 0–1
  const sat = 0.7 + Math.random()*0.3; // 0.7–1.0
  const light = 0.5 + Math.random()*0.2; // 0.5–0.7
  const color = new THREE.Color().setHSL(hue, sat, light);
  mat.color.copy(color);
}

 let vx = 1.00;

let vy = 1.00;

const RADIUS = radius;

 // Calculate half-sizes because (0,0) is in the center
        const RIGHT_EDGE = PLAY_WIDTH / 2;
        const LEFT_EDGE = -PLAY_WIDTH / 2;
        const TOP_EDGE = PLAY_HEIGHT / 2;
        const BOTTOM_EDGE = -PLAY_HEIGHT / 2;

// assume WIDTH and HEIGHT are your viewport or container size

function animate() {

  requestAnimationFrame(animate);



  // read current position

  let x = circle.position.x;

  let y = circle.position.y;



  // advance

  x += vx;

  y += vy;

  let collided = false;

   // Check Right Wall (+250)
            if (x + RADIUS >= RIGHT_EDGE) {
                x = RIGHT_EDGE - RADIUS;
                vx = (Math.random() * 2 - 1) * 2;
                collided = true;
            } 
            // Check Left Wall (-250)
            else if (x - RADIUS <= LEFT_EDGE) {
                x = LEFT_EDGE + RADIUS;
                vx = (Math.random() * 2 - 1) * 2;
                collided = true;
            }

            // --- Y COLLISION (Top and Bottom) ---
            // Check Top Wall (+250)
            if (y + RADIUS >= TOP_EDGE) {
                y = TOP_EDGE - RADIUS;
                vy = (Math.random() * 2 - 1) * 2;
                collided = true;
            } 
            // Check Bottom Wall (-250)
            else if (y - RADIUS <= BOTTOM_EDGE) {
                y = BOTTOM_EDGE + RADIUS;
                vy = (Math.random() * 2 - 1) * 2;
                collided = true;
            }
  
            if (collided) {
              setRandomColor(circleMaterial);
            }
  // Apply position
  circle.position.set(x, y, 0);
  render();
}


	function render() {
		//cameraControls.update();
		renderer.render(scene, camera);
	}
	animate();
	</script>
</html>
